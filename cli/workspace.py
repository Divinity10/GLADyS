#!/usr/bin/env python3
"""Manage isolated agent workspaces for multi-agent parallel development.

Usage:
    uv run cli/workspace.py create NAME    Create workspace ../GLADys-NAME/
    uv run cli/workspace.py list           List all workspaces
    uv run cli/workspace.py destroy NAME   Remove workspace and database
"""

import os
import shutil
import subprocess
import sys
from pathlib import Path

REPO_ROOT = Path(__file__).resolve().parent.parent

# Port scheme: workspace slot N gets base + N*100
BASE_GRPC_PORT = 50050
BASE_DASHBOARD_PORT = 8502
PORT_STEP = 100

# Known workspace names get stable slot assignments
KNOWN_SLOTS = {"claude": 1, "codex": 2, "gemini": 3}


def workspace_dir(name: str) -> Path:
    return REPO_ROOT.parent / f"GLADys-{name}"


def get_remote_url() -> str:
    r = subprocess.run(
        ["git", "remote", "get-url", "origin"],
        capture_output=True, text=True, cwd=REPO_ROOT,
    )
    return r.stdout.strip() if r.returncode == 0 else ""


def find_workspaces() -> list[tuple[str, Path]]:
    """Find existing workspace directories.

    Checks known workspace names + a reasonable range of auto-assigned slots
    rather than scanning the parent directory (which can trigger OneDrive
    hydration on Windows if other OneDrive-synced folders are nearby).
    """
    result = []
    # Check known names + slots 4-9 for auto-assigned workspaces
    candidates = list(KNOWN_SLOTS.keys()) + [f"agent{i}" for i in range(4, 10)]
    for name in candidates:
        ws = REPO_ROOT.parent / f"GLADys-{name}"
        if ws.is_dir() and (ws / ".git").exists():
            result.append((name, ws))
    return result


def get_slot(name: str) -> int:
    """Get port offset slot for a workspace name."""
    if name.lower() in KNOWN_SLOTS:
        return KNOWN_SLOTS[name.lower()]
    # Auto-assign: find first unused slot >= 4
    used = set(KNOWN_SLOTS.values())
    for ws_name, _ in find_workspaces():
        if ws_name.lower() in KNOWN_SLOTS:
            used.add(KNOWN_SLOTS[ws_name.lower()])
    slot = 4
    while slot in used:
        slot += 1
    return slot


def read_primary_env_vars() -> dict[str, str]:
    """Read primary .env as key-value pairs."""
    env_file = REPO_ROOT / ".env"
    pairs = {}
    if env_file.exists():
        with open(env_file, encoding="utf-8") as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith("#"):
                    continue
                if "=" in line:
                    key, _, val = line.partition("=")
                    pairs[key.strip()] = val.strip()
    return pairs


def generate_env(name: str, slot: int) -> str:
    """Generate workspace .env content with offset ports."""
    grpc_base = BASE_GRPC_PORT + slot * PORT_STEP
    dash_port = BASE_DASHBOARD_PORT + slot * PORT_STEP
    db_name = f"gladys_{name}"

    orch = grpc_base
    mem = grpc_base + 1
    rust = grpc_base + 2
    exe = grpc_base + 3

    # Copy Ollama settings from primary
    primary = read_primary_env_vars()
    ollama_lines = []
    for key, val in primary.items():
        if key.startswith("OLLAMA"):
            ollama_lines.append(f"{key}={val}")

    lines = [
        f"# GLADyS Workspace: {name}",
        f"# Port offset: +{slot * PORT_STEP} | Database: {db_name}",
        f"# Generated by: make workspace-create NAME={name}",
        "",
    ]

    if ollama_lines:
        lines.append("# Ollama (copied from primary)")
        lines.extend(ollama_lines)
        lines.append("")

    lines.extend([
        "# PostgreSQL",
        "STORAGE_HOST=localhost",
        "STORAGE_PORT=5432",
        f"STORAGE_DATABASE={db_name}",
        "STORAGE_USER=gladys",
        "STORAGE_PASSWORD=gladys_dev",
        "",
        "# Service ports (CLI/dashboard connection)",
        f"ORCHESTRATOR_PORT={orch}",
        f"MEMORY_PYTHON_PORT={mem}",
        f"MEMORY_RUST_PORT={rust}",
        f"EXECUTIVE_PORT={exe}",
        f"DASHBOARD_PORT={dash_port}",
        "DB_PORT=5432",
        "",
        "# Service addresses",
        f"ORCHESTRATOR_ADDRESS=localhost:{orch}",
        f"MEMORY_ADDRESS=localhost:{mem}",
        f"SALIENCE_ADDRESS=localhost:{rust}",
        f"EXECUTIVE_ADDRESS=localhost:{exe}",
        "",
        "# Service listen ports (read by each service's config)",
        "# Note: GRPC_PORT is for memory-python; memory-rust also reads GRPC_PORT",
        "# but _local_backend.py overrides it with the correct port at launch.",
        f"PORT={orch}",
        f"GRPC_PORT={mem}",
        f"GRPC_SALIENCE_ADDRESS=localhost:{rust}",
        "",
        "# Orchestrator downstream addresses",
        f"SALIENCE_MEMORY_ADDRESS=localhost:{rust}",
        f"MEMORY_STORAGE_ADDRESS=localhost:{mem}",
        f"EXECUTIVE_ADDRESS=localhost:{exe}",
        "",
        "# Database (read by init_db.py and dashboard)",
        f"DB_NAME={db_name}",
        "DB_HOST=localhost",
        "DB_USER=gladys",
        "DB_PASS=gladys_dev",
        "",
        f"TEST_DB_URL=postgresql://gladys:gladys_dev@localhost:5432/{db_name}_test",
    ])

    return "\n".join(lines) + "\n"


def cmd_create(name: str) -> int:
    ws = workspace_dir(name)
    slot = get_slot(name)
    db_name = f"gladys_{name}"
    grpc_base = BASE_GRPC_PORT + slot * PORT_STEP
    dash_port = BASE_DASHBOARD_PORT + slot * PORT_STEP

    print(f"Creating workspace '{name}'")
    print(f"  Directory: {ws}")
    print(f"  Ports: {grpc_base}-{grpc_base + 3}, dashboard {dash_port}")
    print(f"  Database: {db_name}")
    print()

    # Clone or skip
    if ws.exists() and (ws / ".git").exists():
        print("  OK    Directory already exists (skipping clone)")
    else:
        remote = get_remote_url()
        if not remote:
            print("  FAIL  Could not determine git remote URL")
            return 1
        print(f"  ...   Cloning from {remote}")
        r = subprocess.run(
            ["git", "clone", remote, str(ws)],
            capture_output=True, text=True,
        )
        if r.returncode != 0:
            print(f"  FAIL  Clone failed: {r.stderr}")
            return 1
        print("  OK    Cloned")

    # Generate .env
    env_content = generate_env(name, slot)
    env_path = ws / ".env"
    with open(env_path, "w", encoding="utf-8", newline="\n") as f:
        f.write(env_content)
    print("  OK    Generated .env")

    # Install dependencies and initialize
    print("  ...   Running make setup (this may take a moment)")
    r = subprocess.run(
        ["make", "setup"],
        capture_output=True, text=True, cwd=ws, timeout=300,
    )
    if r.returncode == 0:
        print("  OK    Setup complete (deps + database)")
    else:
        print("  WARN  Setup had issues (run 'make setup' manually in the workspace)")
        if r.stderr:
            for line in r.stderr.strip().splitlines()[:3]:
                print(f"        {line}")

    print()
    print(f"Workspace '{name}' ready at {ws}")
    print(f"  Dashboard: http://localhost:{dash_port}")
    print(f"  Start:     cd {ws} && make start")
    return 0


def cmd_list() -> int:
    workspaces = find_workspaces()
    if not workspaces:
        print("No workspaces found.")
        print("Create one with: make workspace-create NAME=codex")
        return 0

    print(f"{'Name':<12} {'gRPC Ports':<16} {'Dashboard':<12} {'Database':<20} {'Path'}")
    print("-" * 90)

    for name, path in workspaces:
        slot = get_slot(name)
        grpc_base = BASE_GRPC_PORT + slot * PORT_STEP
        dash_port = BASE_DASHBOARD_PORT + slot * PORT_STEP
        db_name = f"gladys_{name}"
        grpc_range = f"{grpc_base}-{grpc_base + 3}"
        print(f"{name:<12} {grpc_range:<16} {dash_port:<12} {db_name:<20} {path}")

    return 0


def cmd_destroy(name: str) -> int:
    ws = workspace_dir(name)
    db_name = f"gladys_{name}"

    if not ws.exists():
        print(f"Workspace '{name}' not found at {ws}")
        return 1

    # Confirm
    answer = input(f"Destroy workspace '{name}' (drop DB '{db_name}', remove {ws})? [y/N] ")
    if answer.lower() != "y":
        print("Cancelled.")
        return 0

    # Drop database
    r = subprocess.run(
        ["psql", "-h", "localhost", "-p", "5432", "-U", "gladys", "-d", "postgres",
         "-c", f'DROP DATABASE IF EXISTS "{db_name}";'],
        capture_output=True, text=True,
        env={**os.environ, "PGPASSWORD": "gladys_dev"},
    )
    if r.returncode == 0:
        print(f"  OK    Dropped database '{db_name}'")
    else:
        print(f"  WARN  Could not drop database: {r.stderr.strip()}")

    # Also drop test database
    subprocess.run(
        ["psql", "-h", "localhost", "-p", "5432", "-U", "gladys", "-d", "postgres",
         "-c", f'DROP DATABASE IF EXISTS "{db_name}_test";'],
        capture_output=True, text=True,
        env={**os.environ, "PGPASSWORD": "gladys_dev"},
    )

    # Remove directory
    shutil.rmtree(ws)
    print(f"  OK    Removed {ws}")

    print(f"Workspace '{name}' destroyed.")
    return 0


def main() -> int:
    if len(sys.argv) < 2:
        print(__doc__)
        return 1

    command = sys.argv[1]

    if command == "create":
        if len(sys.argv) < 3:
            print("Usage: workspace.py create NAME")
            return 1
        return cmd_create(sys.argv[2])
    elif command == "list":
        return cmd_list()
    elif command == "destroy":
        if len(sys.argv) < 3:
            print("Usage: workspace.py destroy NAME")
            return 1
        return cmd_destroy(sys.argv[2])
    else:
        print(f"Unknown command: {command}")
        print(__doc__)
        return 1


if __name__ == "__main__":
    sys.exit(main())
